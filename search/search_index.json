{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Flecto is a fluent, type-safe SQL SELECT query generator and filtering layer for .NET 9+,  focusing on structured filtering, sorting, and pagination at the moment.  While designed for seamless use with Dapper, Flecto is provider-agnostic and extensible,  allowing you to integrate it with other data access providers and SQL dialects  as project evolves.</p>"},{"location":"#why-flecto","title":"Why Flecto?","text":"<p>Manual SQL string construction for dynamic reads is error-prone and hard to maintain.  Flecto enables you to safely and clearly build dynamic SELECT queries with structured filters  and sorting while ensuring safe parameterization and testable filtering logic,  reducing repetitive boilerplate in your services.</p>"},{"location":"#who-is-flecto-for","title":"Who is Flecto for?","text":"<ul> <li>Developers building HTTP APIs and services needing dynamic, structured, type-safe querying.</li> <li>Teams seeking to eliminate manual SQL construction for dynamic SELECTs while retaining control over query generation.</li> <li>Applications requiring validated, structured filtering and sorting in a clean, maintainable way.</li> <li>Systems that may evolve to support multiple database providers and SQL dialects.</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Fluent API for SELECT Queries: Compose structured read queries using <code>Select()</code>, <code>BindNumeric()</code>, <code>BindString()</code>, <code>Search()</code>, etc .</li> <li>Structured Filtering: Strongly-typed filters (<code>NumericFilter</code>, <code>StringFilter</code>, <code>BoolFilter</code>, etc.) with validation and extensibility.</li> <li>Safe Parameterization: Manages SQL parameters automatically to prevent injection vulnerabilities.</li> <li>Sorting and Pagination: Type-safe, declarative sorting and paging.</li> <li>Provider and Dialect Extensibility: Built-in support for PostgreSQL with an extensible architecture for SQL Server, MySQL, and other dialects/providers.</li> <li>Cloneable Queries: Easily adjust and re-use queries with <code>.Clone()</code>.</li> <li>Focused on SELECT: Purpose-built for safe, dynamic read queries in HTTP APIs and services.</li> </ul>"},{"location":"#filters","title":"Filters","text":"<p>Flecto uses structured, type-safe filters that support validation and null checks,  enabling clean, maintainable filtering before executing read queries.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Filters: Defining and applying structured filters.</li> <li>Validations: Integrating and extending validation.</li> <li>Bindings: Using filters with HTTP and JSON binding.</li> <li>Usages: Practical examples with Dapper and other providers.</li> <li>Roadmap: Planned enhancements for Flecto.</li> </ul>"},{"location":"bindings/","title":"Bindings","text":""},{"location":"bindings/#bindings","title":"Bindings","text":"<p>Flecto's binding mechanism allows you to fluently connect filters to specific database columns,  forming the foundation of a dynamic and type-safe query.</p> <p>This is done using the <code>FlectoBuilder</code> class and its fluent methods such as  <code>BindNumeric</code>, <code>BindString</code>, <code>BindBool</code>, <code>Search</code>, and others.  Each method binds a provided filter instance to one or more SQL column names,  safely translating user inputs into parameterized SQL expressions.</p>"},{"location":"bindings/#basic-usage","title":"Basic Usage","text":"<pre><code>var builder = new FlectoBuilder(\"employee\", DialectType.Postgres)\n    .Search(r.Search, [\"first_name\", \"last_name\", \"middle_name\", \"profile-&gt;'is_active'\"])\n    .BindNumeric(r.Id, \"id\")\n    .BindString(r.Name, \"first_name\")\n    .BindNumeric(r.Salary, \"salary\");\n\nvar (sqlCount, parametersCount) = builder\n    .Clone()\n    .SelectCount()\n    .Build();\n\nvar totalRecords = await connection.QueryFirstAsync&lt;int&gt;(sqlCount, parametersCount);\n\nvar (sql, parameters) = builder\n    .SelectAll()\n    .ApplyPaging(r.Paging)\n    .Build();\n\nvar employees = await connection.QueryAsync&lt;Employee&gt;(sql, parameters);\n</code></pre>"},{"location":"bindings/#key-binding-methods","title":"Key Binding Methods","text":"<ul> <li><code>BindNumeric(filter, column)</code> \u2014 binds a <code>NumericFilter&lt;T&gt;</code> to a column.</li> <li><code>BindString(filter, column)</code> \u2014 binds a <code>StringFilter</code>.</li> <li><code>BindBool(filter, column)</code> \u2014 binds a <code>BoolFilter</code>.</li> <li><code>BindGuid(filter, column)</code> \u2014 binds a <code>GuidFilter</code>.</li> <li><code>BindDate(filter, column)</code> \u2014 binds a <code>DateFilter</code>.</li> <li><code>BindEnum(filter, column, EnumFilterMode mode)</code> \u2014 binds an <code>EnumFilter&lt;T&gt;</code> where you can set which data you have in db via <code>EnumFilterMode</code>.</li> <li><code>BindFlagsEnum(filter, column)</code> \u2014 binds a <code>[Flags]</code> enum filter.</li> <li><code>Search(filter, columns...)</code> \u2014 binds an <code>SearchFilter</code> where applies a search filter using <code>ILIKE</code> or full-text search depending on dialect.</li> <li><code>SearchTsVector(filter, columns, TextSearchMode mode, config)</code> \u2014 binds an <code>SearchFilter</code>where applies a TsVector search.</li> <li><code>ApplyPaging(filter)</code> \u2014 bind a <code>PaginationFilter</code>, where applies paging with Page and Limit params.</li> </ul> <p>All binding methods automatically:</p> <ul> <li>Perform null-checks and skip filters not provided;</li> <li>Build every column with table prefix: <code>table.column</code>, use auto type-casting if you want to work with json fields. </li> <li>Safely parameterize SQL values to prevent SQL injection.</li> <li>Validate filters internally (via <code>EnsureValid</code>) and validate table and column(s) naming;</li> </ul>"},{"location":"bindings/#query-composition-notes","title":"Query Composition Notes","text":"<ul> <li>Currently supports only single-table queries;</li> <li>All <code>Bind*</code> and <code>Search</code> methods are translated into the <code>WHERE</code> clause using logical AND;</li> <li>Multiple <code>Bind*</code> calls will append conditions conjunctively;</li> <li>Selection options include:</li> <li><code>SelectAll()</code> \u2014 SELECT *</li> <li><code>SelectCount()</code> \u2014 SELECT COUNT(*) with ORDER BY skipped</li> <li><code>Select(columns)</code> \u2014 SELECT specific columns</li> <li>not allow manual select logic at the moment</li> </ul>"},{"location":"bindings/#column-registration","title":"Column registration","text":"<p>If you want to use <code>Select(...)</code> with predefined column arrays, you should register them with the <code>FromTable</code> class. This allows Flecto to validate tables and columns and ensures consistent query building.</p> <p>To implement, import the class from <code>Flecto.Core.Models.Select</code> and initialize it like this:</p> <pre><code>private readonly FromTable _tc = new FromTable(\n    table: \"table_name\",\n    fields: new Field[]{\n        new Field(column: \"column_1\"),\n        new Field(column: \"column_2\"),\n        new Field(column: \"column2-&gt;'is_active'\", alias: \"social_networks_is_active\")\n});\n</code></pre>"},{"location":"bindings/#optional-clone-and-count","title":"Optional Clone and Count","text":"<p>You can safely clone a builder mid-way and use it to perform a <code>COUNT(*)</code> query:</p> <pre><code>var (sqlCount, parametersCount) = builder.Clone().SelectCount().Build();\n</code></pre> <p>This helps compute total pagination values before fetching the actual page.</p> <p>\ud83d\udca1 Want to return paginated results with metadata?</p> <p>\u2192 Check out Usages - to learn how to wrap Flecto queries using <code>SearchResult&lt;T&gt;</code> and return structured responses.</p>"},{"location":"filters/","title":"Filters","text":"<p>Flecto uses structured, type-safe filters to build clean, safe, and dynamic SQL SELECT queries  across providers. Filters ensure your read operations are clear and maintainable while preventing  SQL injection and supporting validation before executing queries.</p>"},{"location":"filters/#why-use-filters","title":"Why use filters?","text":"<ul> <li>Eliminate manual SQL WHERE clause construction.</li> <li>Apply dynamic filters safely without boilerplate.</li> <li>Enable validated, composable filtering for APIs and services.</li> <li>Support clear API contracts and frontend filter builders.</li> </ul>"},{"location":"filters/#available-filters","title":"Available Filters","text":""},{"location":"filters/#boolfilter","title":"<code>BoolFilter</code>","text":"<p>Used for filtering boolean columns.</p> <p>Key properties:</p> <ul> <li><code>Eq</code>: filter by true/false.</li> <li><code>IsNull</code>: filter for null values.</li> <li><code>Sort</code>: sorting direction.</li> </ul> <p>Example: <pre><code>var filter = new BoolFilter { Eq = true };\n</code></pre></p>"},{"location":"filters/#datefilter","title":"<code>DateFilter</code>","text":"<p>Used for filtering date columns with exact match or ranges.</p> <p>Key properties:</p> <ul> <li><code>Eq</code> / <code>NotEq</code>: exact date match or exclusion.</li> <li><code>Gt</code> / <code>Gte</code>, <code>Lt</code> / <code>Lte</code>: range filtering.</li> <li><code>In</code> / <code>NotIn</code>: inclusion/exclusion by list.</li> <li><code>IsNull</code>: filter for null values.</li> <li><code>Sort</code>: sorting direction.</li> </ul> <p>Example: <pre><code>var filter = new DateFilter \n{ \n    Gt = new DateTime(1970, 01, 01), \n    Lt = new DateTime(2000, 01, 01) \n};\n</code></pre></p>"},{"location":"filters/#enumfiltert","title":"<code>EnumFilter&lt;T&gt;</code>","text":"<p>Used for filtering enum columns by name or numeric value.</p> <p>Key properties:</p> <ul> <li><code>Eq</code> / <code>NotEq</code>: exact enum match or exclusion.</li> <li><code>In</code> / <code>NotIn</code>: inclusion/exclusion by list.</li> <li><code>IsNull</code>: filter for null values.</li> <li><code>Sort</code>: sorting direction.</li> </ul> <p>Example: <pre><code>var filter = new EnumFilter&lt;UserStatus&gt; { Eq = UserStatus.Active };\n</code></pre></p>"},{"location":"filters/#flagsenumfiltert","title":"<code>FlagsEnumFilter&lt;T&gt;</code>","text":"<p>Used for filtering columns that store flags-style enums using bitwise operations,  enabling type-safe filtering for flags enums.</p> <p>Key properties:</p> <ul> <li><code>Eq</code>: filter for exact enum value.</li> <li><code>NotEq</code>: filter for inequality with the specified enum value.</li> <li><code>HasFlag</code>: filter where the specified flag is set.</li> <li><code>NotHasFlag</code>: filter where the specified flag is not set.</li> <li><code>IsNull</code>: filter for null values.</li> <li><code>Sort</code>: sorting direction.</li> </ul> <p>Example:</p> <pre><code>var filter = new FlagsEnumFilter&lt;UserPermissions&gt; { HasFlag = UserPermissions.Admin };\n</code></pre>"},{"location":"filters/#guidfilter","title":"<code>GuidFilter</code>","text":"<p>Used for filtering <code>Guid</code> columns with support for exact matching, inclusion/exclusion, null checks, and sorting.</p> <p>Key properties:</p> <ul> <li><code>Eq</code>: filter for exact <code>Guid</code> value.</li> <li><code>NotEq</code>: filter for inequality with the specified <code>Guid</code>.</li> <li><code>In</code>: filter for inclusion within a list of <code>Guid</code> values.</li> <li><code>NotIn</code>: filter for exclusion from a list of <code>Guid</code> values.</li> <li><code>IsNull</code>: filter for null values.</li> <li><code>Sort</code>: sorting direction.</li> </ul> <p>Example:</p> <pre><code>var filter = new GuidFilter\n{\n    NotIn = new Guid[]\n    {\n        Guid.Parse(\"5a1d2b3c-6f4e-4d7b-9c2f-8b5c4e7d9f10\"),\n        Guid.Parse(\"3f4b5a6c-2e1d-4c3b-8f7e-5d6c7b8a9e01\")\n    },\n    Sort = Sort.Desc\n};\n</code></pre>"},{"location":"filters/#numericfiltert","title":"<code>NumericFilter&lt;T&gt;</code>","text":"<p>Used for filtering numeric columns with full support for comparison operations,  inclusion/exclusion, null checking, and sorting.</p> <p>Key properties:</p> <ul> <li><code>Eq</code> / <code>NotEq</code>: exact equality or inequality.</li> <li><code>Gt</code> / <code>Gte</code>: greater than, greater than or equal.</li> <li><code>Lt</code> / <code>Lte</code>: less than, less than or equal.</li> <li><code>In</code> / <code>NotIn</code>: inclusion or exclusion by list.</li> <li><code>IsNull</code>: filter for null values.</li> <li><code>Sort</code>: sorting direction.</li> </ul> <p>Support types</p> <ul> <li><code>short, int, long, decimal, double, float</code></li> </ul> <p>Example: <pre><code>var filter = new NumericFilter&lt;int&gt; \n{ \n    Gte = 18, \n    Lt = 65, \n    Sort = { Position = 1, Descending = false} \n};\n</code></pre></p>"},{"location":"filters/#paginationfilter","title":"<code>PaginationFilter</code>","text":"<p>Used user-friendly filter for controlling pagination in your queries,  allowing clients to request data in manageable chunks.</p> <p>Key properties:</p> <ul> <li><code>Limit</code>: maximum number of items to return.</li> <li><code>Page</code>: page number to retrieve.</li> </ul> <p>Example: <pre><code>var filter = new PaginationFilter\n{\n    Limit = 50,\n    Page = 2\n};\n</code></pre></p>"},{"location":"filters/#searchfilter","title":"<code>SearchFilter</code>","text":"<p>Used for performing free-text search across specific columns in your queries,  supporting OR-based matching or integration with <code>tsvector</code> for PostgreSQL full-text search.</p> <p>Key properties:</p> <ul> <li><code>Value</code>: the search string to match.</li> <li><code>CaseSensitive</code>: determines if the search should be case-sensitive.</li> </ul> <p>Example:</p> <pre><code>var filter = new SearchFilter\n{\n    Value = \"project manager\",\n    CaseSensitive = false\n};\n</code></pre>"},{"location":"filters/#sort","title":"<code>Sort</code>","text":"<p><code>Sort</code> is used across all filters in Flecto to define sorting behavior on query properties,  supporting multi-column and user-defined sorting orders.</p> <p>Key properties:</p> <ul> <li><code>Position</code>: defines the sort priority among multiple sorted columns.</li> <li><code>Descending</code>: determines if the sort direction is descending (<code>true</code>) or ascending (<code>false</code>).</li> </ul> <p>Example:</p> <pre><code>var sort = new Sort(position: 1, descending: true);\n</code></pre>"},{"location":"filters/#stringfilter","title":"<code>StringFilter</code>","text":"<p>Used for filtering string columns with pattern matching.</p> <p>Key properties:</p> <ul> <li><code>Eq</code> / <code>NotEq</code>: exact match or exclusion.</li> <li><code>Contains</code>, <code>StartsWith</code>, <code>EndsWith</code>: pattern searches.</li> <li><code>In</code> / <code>NotIn</code>: inclusion/exclusion by list.</li> <li><code>IsNull</code>: filter for null values.</li> <li><code>Sort</code>: sorting direction.</li> <li><code>CaseSensitive</code>: case-insensitive comparison.</li> </ul> <p>Example: <pre><code>var filter = new StringFilter { Contains = \"admin\", CaseSensitive = true };\n</code></pre></p>"},{"location":"filters/#custom-filter-projection","title":"Custom Filter Projection","text":"<p>Flecto filters are modular and reusable, but sometimes you may want to restrict or  simplify their functionality for public APIs or external consumers. </p> <p>For example, you may want to disallow sorting and array-based operations  like <code>In</code> and <code>NotIn</code> from <code>NumericFilter&lt;T&gt;</code>.</p> <p>You can achieve this by introducing a custom DTO (e.g., <code>CustomNumericFilter</code>)  and mapping it internally to Flecto's standard filters.</p>"},{"location":"filters/#example-customizing-numericfiltert","title":"Example: Customizing <code>NumericFilter&lt;T&gt;</code>","text":"<pre><code>public class CustomNumericFilter\n{\n    public int? Eq { get; set; }\n    public int? NotEq { get; set; }\n}\n</code></pre> <p>Then map it inside your application or service layer:</p> <pre><code>var mapped = new NumericFilter&lt;int&gt;\n{\n    Eq = request.Id?.Eq,\n    NotEq = request.Id?.NotEq\n};\n</code></pre> <p>Use the mapped version in your builder:</p> <pre><code>var builder = new FlectoBuilder(\"employees\", DialectType.Postgres)\n    .BindNumeric(mapped, \"id\")\n    .Select(\"*\");\n</code></pre> <p>This allows you to:</p> <ul> <li>Hide advanced options like sorting or range filtering from end users.</li> <li>Provide strict or simplified filters for public APIs.</li> <li>Maintain full compatibility with the internal Flecto engine.</li> </ul>"},{"location":"filters/#usage-example","title":"Usage Example","text":"<p>Filters in Flecto are typically used together with FlectoBuilder to dynamically construct SQL SELECT Details about FlectoBuilder will be covered in the next sections.</p> <pre><code>var (sqlCount, parametersCount) = new FlectoBuilder(\"table_name\", DialectType.Postgres)\n    .BindNumeric(\"age\", filter.Age)\n    .BindString(\"name\", filter.Name)\n    .ApplyPaging(request.Page, request.PageSize)\n    .Build();\n</code></pre> <p>Filters in Flecto help keep your query layer clean, safe, and adaptable while supporting structured  dynamic query building.</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#roadmap","title":"Roadmap","text":"<p>This roadmap outlines the planned evolution of Flecto, focusing on improving extensibility,  developer experience, and broader ecosystem integrations.</p>"},{"location":"roadmap/#short-term-goals","title":"Short-Term Goals","text":"<p>These features are either in development or high-priority in the near term.</p> <ul> <li>JOIN and ON support: Enable <code>.Join(...)</code> and <code>.On(...)</code> clauses for building queries involving related tables.</li> <li>Support GET requests</li> <li>GET request support with hybrid sorting:</li> <li>Example: <code>?sort=name,-createdAt</code> to mix ascending/descending.</li> <li>DISTINCT support:</li> <li>Add support for deduplication of selected results via <code>.Distinct()</code>.</li> <li>Support system-level extended filters:</li> <li>Add <code>.AndWhere(...)</code> APIs for advanced scenarios.</li> </ul>"},{"location":"roadmap/#long-term-ideas","title":"Long-Term Ideas","text":"<p>These ideas are under consideration but not yet scheduled.</p> <ul> <li>Type-safe query composition with source generators</li> <li>JQL support</li> <li>UI autocomplete schema builder/generator integration</li> <li>...</li> </ul>"},{"location":"roadmap/#notes","title":"Notes","text":"<ul> <li>All roadmap items are modular. Features will be added in a non-breaking, opt-in manner.</li> <li>You can follow the releases and progress via GitHub milestones and discussions.</li> </ul> <p>This roadmap may evolve based on feedback, contributions, and internal priorities.</p>"},{"location":"usages/","title":"Usages","text":""},{"location":"usages/#usages","title":"Usages","text":"<p>This section demonstrates practical usage patterns of the Flecto library in real applications.  From simple filter binding to executing queries and returning paginated results,  this guide covers typical end-to-end flows.</p>"},{"location":"usages/#1-full-request-response-flow","title":"1. Full Request-Response Flow","text":"<p>This is the most common scenario in web APIs.  A client sends a request, filters are validated, and a dynamic SQL query is built using Flecto  and executed via Dapper.</p> <pre><code>flowchart LR\n    B --&gt; C\n    F --&gt; G\n\n\n    subgraph -IN- Presentaion Layer\n        A[Client Request #40;POST /search#41;] --&gt; B[Validation: e.g. via FluentValidation]\n    end\n\n    subgraph Repo Layer\n        C[FlectoBuilder] --&gt; D(Select \u2192.Search \u2192 .BindX \u2192 .ApplyPaging \u2192 .Build#40;#41;)\n        C --&gt; E(Clone#40;#41;.SelectCount#40;#41;.Build#40;#41;)\n        E --&gt; F[SearchResult&amp;lt;T&amp;gt;]\n        D --&gt; F\n\n    end\n\n    subgraph -OUT- Presentaion Layer\n        G[Client Response with pagination]\n    end</code></pre> <p>Example: <pre><code>// Request.cs\n\npublic class Request\n{\n    public SearchFilter? Search { get; set; }\n    public StringFilter? Name { get; set; }\n    public NumericFilter&lt;decimal&gt;? Salary { get; set; }\n    public PaginationFilter? Paging { get; set; }\n}\n\n// Response.cs\n\npublic class Response\n{\n    public SearchResult&lt;Employee[]&gt;? Data { get; set; }\n}\n\n// Controller.cs\n//...\n[HttpPost(\"PostSearch\")]\npublic async Task&lt;ActionResult&lt;Response&gt;&gt; PostSearch(\n    Request r, \n    CancellationToken token)\n{\n    var result = await _svc.Search(r, token);\n    return Ok(new Response { Data = result });\n}\n//...\n\n// Validator.cs\n// ... e.g. FluentValidation\n// ...\nRuleFor(x =&gt; x.BoolFilter)\n    .Custom((filter, context) =&gt;\n    {\n        var errors = GetBoolFilterValidationErrors(filter, requireAtLeastOne: false);\n\n        foreach (var error in errors)\n        {\n            context.AddFailure(error.Field, error.Error);\n        }\n    });\n// ...\n\n// Repository.cs\n// ...\n// ...\n\n\nprivate readonly FromTable _tc = new FromTable(\n    table: _employeeTable,\n    fields: new Field[]{\n        new Field(\"id\"),\n        new Field(\"social_networks-&gt;'is_active'\", \"social_networks_is_active\")\n});\n\npublic async Task&lt;SearchResult&lt;Employee[]&gt;&gt; Search(Request r, CancellationToken token)\n{\n    var builder = new FlectoBuilder(_employeeTable, DialectType.Postgres)\n        .Search(r.Search, \"first_name\", \"last_name\", \"middle_name\", \"notes\")\n        .BindNumeric(r.Id, \"id\")\n        .BindString(r.Name, \"first_name\")\n        .BindNumeric(r.Salary, \"salary\");\n\n    var (sqlCount, parametersCount) = builder\n        .Clone()\n        .SelectCount()\n        .Build();\n\n    using var connection = await CreateConnectionAsync();\n\n    var totalRecords = await connection.QueryFirstAsync&lt;int&gt;(sqlCount, parametersCount);\n\n    var (sql, parameters) = builder\n        .Select(_tc)\n        .ApplyPaging(r.Paging)\n        .Build();\n\n    var employees = await connection.QueryAsync&lt;Employee&gt;(sql, parameters);\n\n    return new SearchResult&lt;Employee[]&gt;(\n            employees.ToArray(),\n            SearchMetadata.From(totalRecords, r.Paging));\n}\n</code></pre></p>"},{"location":"usages/#2-service-layer-query-flow","title":"2. Service-Layer Query Flow","text":"<pre><code>flowchart LR\n    A --&gt; B\n    C --&gt; D\n\n\n    subgraph Service Layer\n       A[Create Filters]\n    end\n\n    subgraph Repo Layer\n        B[FlectoBuilder] --&gt; C(Select \u2192.Search \u2192 .BindX \u2192 .ApplyPaging \u2192 .Build#40;#41;)     \n    end\n\n    subgraph OUT \n       D[Result]\n    end</code></pre> <p>Example: <pre><code>// Service.cs\n\n// ...\n\npublic async Task&lt;Employee&gt; GetEmployee(long id, CancellationToken token)\n{\n    var f = new NumericFilter&lt;long&gt; { Eq = id };\n    result = await _repo.GetEmployee(f, token);\n}\n\n// ...\n\n// Repository.cs\n\n// ...\n\npublic async Task&lt;Employee&gt; GetEmployee(NumericFilter&lt;long&gt; f, CancellationToken token)\n{\n    var builder = new FlectoBuilder(_employeeTable, DialectType.Postgres)\n        .Select(_employeeAllColumn)\n        .BindNumeric(r.Id, \"id\")\n\n    using var connection = await CreateConnectionAsync();\n    var employees = await connection.QueryAsync&lt;Employee&gt;(sql, parameters);\n\n    return employees.FirstOrDefault();\n}\n\n// ...\n</code></pre></p>"},{"location":"validations/","title":"Validations","text":"<p>Flecto provides a built-in validation mechanism to verify that filters are logically  consistent before executing a query. Depending on the use case, it can either throw  exceptions immediately or return structured errors to support user-facing validation.  This adds a layer of safety and prevents malformed or  logically incorrect inputs from being processed.</p>"},{"location":"validations/#key-principles","title":"Key principles:","text":"<ul> <li>Filters are only validated if provided (i.e., not null),      but when present, they are always subjected to built-in logical checks.</li> <li>These checks are executed during query construction and use <code>Ensure</code>-style      strict validation by default (throwing exceptions on invalid input).</li> <li>Validation logic uses the same methods for both internal and external validation:      internally, it throws exceptions on invalid input (e.g., via <code>Ensure</code>),      while externally, it can return structured errors to support user-facing      validation. Developers can also inject additional custom validation logic      (e.g., business rules) into the same mechanism.</li> <li>You can also integrate Flecto filters into external validators like FluentValidation.</li> </ul>"},{"location":"validations/#built-in-behavior","title":"Built-in behavior","text":"<p>Each filter in Flecto has a corresponding validator that performs  basic logical consistency checks to ensure correct usage and guard against  invalid combinations of values.</p> <p>Below is a summary of built-in validation logic per filter type:</p>"},{"location":"validations/#boolfilter","title":"<code>BoolFilter</code>","text":"<ul> <li>Disallows using <code>Eq</code> and <code>NotEq</code> simultaneously.</li> <li>If <code>RequireAtLeastOne</code> is set, requires at least one of <code>Eq</code>, <code>NotEq</code>, or <code>Null</code>.</li> <li>Invokes <code>customValidator</code> if provided and includes its result.</li> </ul>"},{"location":"validations/#datefilter","title":"<code>DateFilter</code>","text":"<ul> <li>Disallows using <code>Eq</code> and <code>NotEq</code> simultaneously.</li> <li>Ensures range boundaries <code>Gt</code>, <code>Gte</code>, <code>Lt</code>, and <code>Lte</code> are logically consistent.</li> <li>Validates that <code>In</code> and <code>NotIn</code> arrays are not empty if provided.</li> <li>Invokes <code>customValidator</code> if provided.</li> </ul>"},{"location":"validations/#enumfiltert","title":"<code>EnumFilter&lt;T&gt;</code>","text":"<ul> <li>Disallows using <code>Eq</code> and <code>NotEq</code> simultaneously.</li> <li>Validates that <code>In</code> and <code>NotIn</code> arrays are not empty if provided.</li> <li>Invokes <code>customValidator</code> if provided.</li> </ul>"},{"location":"validations/#flagsenumfiltert","title":"<code>FlagsEnumFilter&lt;T&gt;</code>","text":"<ul> <li>Disallows using <code>Eq</code> and <code>NotEq</code> simultaneously.</li> <li>Disallows setting both <code>HasFlag</code> and <code>NotHasFlag</code> at the same time.</li> <li>Invokes <code>customValidator</code> if provided.</li> </ul>"},{"location":"validations/#guidfilter","title":"<code>GuidFilter</code>","text":"<ul> <li>Disallows using <code>Eq</code> and <code>NotEq</code> simultaneously.</li> <li>Validates that <code>In</code> and <code>NotIn</code> arrays are not empty if provided.</li> <li>Invokes <code>customValidator</code> if provided.</li> </ul>"},{"location":"validations/#numericfiltert","title":"<code>NumericFilter&lt;T&gt;</code>","text":"<ul> <li>Disallows using <code>Eq</code> and <code>NotEq</code> simultaneously.</li> <li>Ensures logical consistency of range fields: <code>Gt</code>, <code>Gte</code>, <code>Lt</code>, and <code>Lte</code>.</li> <li>Validates that <code>In</code> and <code>NotIn</code> arrays are not empty if provided.</li> <li>Invokes <code>customValidator</code> if provided.</li> </ul>"},{"location":"validations/#paginationfilter","title":"<code>PaginationFilter</code>","text":"<ul> <li>Validates that <code>Limit</code> and <code>Page</code> are greater than zero.</li> <li>If <code>maxLimit</code> is specified, ensures <code>Limit</code> does not exceed it.</li> <li>Returns an error if the filter itself is null.</li> </ul>"},{"location":"validations/#searchfilter","title":"<code>SearchFilter</code>","text":"<ul> <li>Requires <code>Value</code> to be non-empty and not just whitespace.</li> <li>Validates that <code>Value</code> meets optional <code>minLength</code> and <code>maxLength</code> constraints if provided.</li> </ul>"},{"location":"validations/#stringfilter","title":"<code>StringFilter</code>","text":"<ul> <li>Validates individual string fields (<code>Eq</code>, <code>NotEq</code>, <code>Contains</code>, <code>StartsWith</code>, <code>EndsWith</code>) for emptiness, length, and optional <code>customValidator</code>.</li> <li>Validates string arrays (<code>In</code>, <code>NotIn</code>) for emptiness, length, and optional <code>customArrayValidator</code>.</li> <li>Honors <code>allowEmptyStrings</code> to control whether empty strings are permitted.</li> <li>Applies <code>maxLength</code> if provided to restrict string length.</li> </ul>"},{"location":"validations/#validation-api","title":"Validation API","text":"<p>Flecto provides per-filter validation methods that return structured errors  in the form of <code>(Field, Error)</code> tuples. These are designed for both internal use  (<code>Ensure(...)</code> for exceptions) and user-facing validation (<code>Validate(...)</code>  for result collection).</p> <p>Each filter type has its own <code>Validate(...)</code> method with a signature tailored to its structure.  All validators:</p> <ul> <li>Apply built-in logical checks (e.g., Eq + NotEq conflict, range consistency, non-empty arrays).</li> <li>Optionally use custom validation logic via <code>Func&lt;TFilter, (bool IsValid, string? Error)&gt;</code>.</li> <li>Return a consistent output: <code>IEnumerable&lt;(string Field, string Error)&gt;</code>.</li> </ul>"},{"location":"validations/#example-flagsenumfilter","title":"Example: FlagsEnumFilter","text":"<pre><code>public static IEnumerable&lt;(string Field, string Error)&gt; Validate(\n    FlagsEnumFilter&lt;UserRole&gt;? filter,\n    Func&lt;FlagsEnumFilter&lt;UserRole&gt;, (bool IsValid, string? ErrorMessage)&gt;? customValidator = null)\n</code></pre> <p>Other filters (e.g. <code>SearchFilter</code>, <code>StringFilter</code>) may also accept <code>maxLength</code>, <code>minLength</code>,  <code>allowEmptyStrings</code>, or custom array validators as additional parameters.</p>"},{"location":"validations/#validation-modes","title":"Validation Modes","text":"<p>There are two usage modes for Flecto's validation system:</p>"},{"location":"validations/#1-internal-ensure-always-enforced-throws-on-error","title":"1. Internal (Ensure) \u2014 always enforced, throws on error","text":"<p>Internal validation logic (<code>EnsureValid(...)</code>) runs automatically during query building  and throws immediately on validation failure.</p> <p>This is useful for internal tools, CLI utilities, or safe programmatic usage or if developer  do not use validation for requests.</p>"},{"location":"validations/#2-user-facing-validate-collects-errors-for-feedback","title":"2. User-facing (Validate) \u2014 collects errors for feedback","text":"<p>You can manually invoke <code>Validate(...)</code> to get a list of validation results and display them to users:</p> <pre><code>var errors = FlagsEnumFilterValidator&lt;UserRole&gt;.Validate(filter);\nif (errors.Any()) {\n    return BadRequest(errors);\n}\n</code></pre> <p>This mode allows API endpoints and UIs to return understandable validation errors instead of throwing.</p>"},{"location":"validations/#example-add-custom-rule","title":"Example: Add custom rule","text":"<pre><code>var errors = FlagsEnumFilterValidator&lt;UserRole&gt;.Validate(\n    filter,\n    customValidator: f =&gt; (!f.Eq.HasValue || f.Eq.Value.HasFlag(UserRole.Admin), \"Only Admins are allowed\"));\n</code></pre>"},{"location":"validations/#example-use-with-fluentvalidation","title":"Example: Use with FluentValidation","text":"<pre><code>RuleFor(x =&gt; x.Role)\n    .Must(f =&gt; !FlagsEnumFilterValidator&lt;UserRole&gt;.Validate(f).Any())\n    .WithMessage(\"Invalid Role filter\");\n</code></pre>"},{"location":"validations/#why-it-matters","title":"Why it matters","text":"<p>Validation gives API developers and consumers predictable behavior, safer filtering,  and early failure before querying the database.</p>"}]}